*************	P	R	O	G	R	A	M		H	E	A	D	E	R	*****************
*****************************************************************************************
*																						*
*	PROGRAM:	3.6 - Arrays.sas                                                        *
*	PURPOSE:	Illustrate material in Chapter 3.6                                      *
*	AUTHOR:		Nelson															*
*	CREATED:	2017-10-18																*
*	                                                                                    *
*	COURSE:		BIOS 6680 - Data Management Using SAS                                   *
*	DATA USED:	[Enter data set name(s)]                                                *
*	SOFTWARE:	SAS (r) Proprietary Software 9.4 (TS1M2)								*
*	MODIFIED:	DATE		BY	REASON													*
*				----------	---	-------------------------------------------------------	*
*               2018-10-20  SMN Added TOC & Comprehension Checks                        *
*               2019-09-20  SMN Added an illustration and minor edits                   *
*	                                                                                    *
*   CONTENTS:                                                                           *
*   	Section 3.6.1 - Array Basics                                                    *
*   	Section 3.6.2 - Using Arrays to Create Variables & Perform Calculations         *
*   	Section 3.6.3 - Combining Arrays with DO Loops                                  *
*   	Section 3.6.4 - Assigning Initial Values to an Array                            *
*   	Section 3.6.5 - Additional Material                                             *
*   	Section 3.6.6 - Solutions                                                       *
*	                                                                                    *
*****************************************************************************************
***********************************************************************************; RUN;




*	SECTION 3.6.1 - ARRAY BASICS   *; RUN;

*	An array is a temporary grouping of variables that exists only during the DATA step
	The variables grouped must be the same type--either all numeric or all character variables
	The variables in an array are referred to as "elements"
	We will work with 1-dimensional arrays (know that multi-dimensional arrays may be used as well)   *;


*	Illustration 1 - Syntax for an ARRAY   *; RUN;

*	SAS arrays are specified using the following ARRAY statement syntax:
	ARRAY	Array-name {subscript} element-list;

*	The array-name must be unique (i.e. not already assigned to a variable)
		The name may be up to 32 characters, and must follow the usual SAS naming conventions
	The subscript describes the number of elements in the array by using a number, range, or *
		The subscript may be enclosed with braces {}, brackets [], or parentheses ()   *;
DATA	WORK.Illus;
	SET	SASHelp.Baseball;
	ARRAY	BBStats {5}	nAtBat nRuns nHits nHome nRBI; * Creates the array "BBStats" *;
	* Note: The order of the elements is different than their order in the source data set
			The variables don't need to be stored adjacent to each other	*;
	RUN;


*	Illustration 2 - Referencing an Array Element   *; RUN;

*	Subscripts are assigned to each element (in the order of the array elements)
		The subscripts are used to reference a specific element in the array
		You can reference a variable by using the array name with the subscript for the variable   *;
DATA	WORK.Illus;
	SET	SASHelp.Baseball;
	ARRAY	BBStats {5}	nAtBat nRuns nHits nHome nRBI;
	NewVbl	= BBStats{4};
	*	Creates 'NewVbl' as a copy of 'nHome' (referenced as the 4th element of BBStats)
		The '4' refers to the 4th variable listed in the array   *;
	RUN;
	
PROC PRINT DATA = WORK.Illus;
	VAR nHome NewVbl;
	RUN;


*	Illustration 3 - Specifying a Range in the Array Subscript   *; RUN;

*	A range of values (which may start at any number) may be used for the subscript
	Suppose the values below represent the number of patients enrolled each month onto a trial   *;
DATA	WORK.Illus;
	INFILE	DATALINES;
	INPUT	Mon1 - Mon12; * Mon1 = January, ... , Mon12 = December *;

	ARRAY	SummerEnr {6:8} Mon6 - Mon8; * This array only contains 3 elements *;
	JulAugPts = SummerEnr{7} + SummerEnr{8};
	DATALINES;
22 25 30 26 20 17 9 11 24 22 19 8
;

PROC PRINT DATA = WORK.Illus;
	RUN;

*	SAS won't recognize values out of the range defined in the subscript   *;
DATA	WORK.Illus;
	INFILE	DATALINES;
	INPUT	Mon1 - Mon12;

	ARRAY	SummerEnr {6:8} Mon6 - Mon8;
	JulAugPts = SummerEnr{1} + SummerEnr{2};
	DATALINES;
22 25 30 26 20 17 9 11 24 22 19 8
;


*	Illustration 3 - Using Shortcuts   *; RUN;

*	Shortcut lists may be used to specify lists of array elements
	Recall:  Shortcut lists are covered in Section 3.3.6   *;
DATA	WORK.Illus;
	SET	SASHelp.Baseball;

	ARRAY	BB {18}	_NUMERIC_; * Includes all numeric variables in the 'BB' array *;

	NewVbl	= BB{17}; * The 17th numeric variable is the 'Salary' variable *;

	RUN;

PROC PRINT DATA = WORK.Illus;
	VAR	Salary NewVbl;
	RUN;


*	Illustration 4 - Using '*' for the Array Subscript   *; RUN;

*	The * character specifies that SAS is to determine the subscript by
		counting the variables in the array
	This is useful when:
		1.	You don't know the number of elements, or
		2.	The number of elements may change for a later submission of the program   *;
DATA	WORK.Illus;
	SET	SASHelp.Baseball;

	ARRAY	BBCareer {*}	Cr:;
	* You might not know how many numeric variables start with 'Cr' (or the number might change) *;
	NewVbl	= BBCareer{3}; * The 3rd numeric variable that starts with 'Cr' *;
	RUN;

PROC PRINT DATA = WORK.Illus;
	VAR	CrHome NewVbl;
	RUN;


*	Illustration 5 - Using the DIM Function   *; RUN;

*	The DIM function returns the number of elements in a SAS array  *;
DATA	WORK.Illus;
	SET	SASHelp.Baseball	(OBS = 1);
	
	ARRAY	BBCareer {*}	Cr:;
	ArrayVblCnt	= DIM(BBCareer);
	RUN;

PROC PRINT DATA = WORK.Illus;
	VAR	ArrayVblCnt;
	RUN;


* ----------------------------- *
|   Comprehension Check 3.6.1   |
* ----------------------------- *
	The in-stream data below is the number of kilometers (km) each person ran for 5 weeks

	Task:  Create an array named 'Km' which contains the 5 variables containing the
				running distances   *;
DATA WORK.RunningLog;
	INFILE	DATALINES;
	INPUT	Name $
			KmWk1 KmWk2 KmWk3 KmWk4 KmWk5;
	DATALINES;
Anderson 10 16 16 26 36
Benson   20 30 37 43 48
Carlson  30 35 37 44 44
;

DATA WORK.RunningLog;
	SET WORK.RunningLog;
	ARRAY Km {*} KmWk1 - KmWk5;
	RUN;




*	SECTION 3.6.2 - USING ARRAYS TO CREATE VARIABLES & PERFORM CALCULATIONS   *; RUN;


*	Illustration 1 - Using the Array Name & Subscript to Create New Variables   *; RUN;

*	If no elements are listed, SAS creates new variables using:
		1.	The array name (e.g. "Month"), and
		2.	Suffixes 1 through the subscript (e.g. "1" through "12")

	The array named 'Month' only lasts for the duration of the DATA step
	However, the variables created remain with the WORK.Illus data set!   *;
DATA	WORK.Illus;
	ARRAY	Month {12};
	Month4 = 30; * The variables may be used in processing *;
	RUN;

PROC PRINT DATA = WORK.Illus;
	RUN;

*	Note:  If suffixes are desired that don't start at 1, include the variable names   *;
DATA	WORK.Illus;
	ARRAY	Year {*} Year1990 - Year2020;
	RUN;

PROC PRINT DATA = WORK.Illus;
	RUN;

*	Note:  Using a range of subscripts works as well
			The subscripts do not have to be the same value as the variable suffix   *;
DATA	WORK.Illus;
	ARRAY	Year {5:20} Year2005 - Year2020;
	Year{6} = 123;
	RUN;

PROC PRINT DATA = WORK.Illus;
	RUN;

*	Note:  Without variables specified, SAS uses 1 through the number of elements (16)
			So when the range doesn't logically start at 1 I typically specify the variable names   *;
DATA	WORK.Illus;
	ARRAY	Year {5:20};
	RUN;

PROC PRINT DATA = WORK.Illus;
	RUN;

*	Note:  Other names may be assigned to the created variables   *;
DATA	WORK.Illus;
	ARRAY	Month {12} Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec;
	RUN;

PROC PRINT DATA = WORK.Illus;
	RUN;


*	Illustration 2 - Creating an Array of Character Variables   *; RUN;

*	Specify the $ character after the subscript to create character variables
	If no length is specified, the default length of 8 is used   *;
DATA	WORK.Illus;
	ARRAY	Symptom {5} $; * Creates 5 character variables, each with a length of 8 *;
	RUN;

PROC PRINT DATA = WORK.Illus;
	RUN;

*	Specify the length after the $ if a length other than 8 is desired   *;
DATA	WORK.Illus;
	ARRAY	Symptom {5} $ 30; * Creates 5 character variables, each with a length of 30 *;
	RUN;

*	Variables may be given different lengths using a LENGTH statement   *;
DATA	WORK.Illus;
	LENGTH	StateCd	$ 2
			StateNm	$ 20
			StateBird StateFlower	$ 15	;
	ARRAY	StateInfo {4} $ StateCd StateNm StateBird StateFlower;
	RUN;

PROC PRINT DATA = WORK.Illus;
	RUN;


*	Illustration 3 - Using an Array Name as a Variable Shortcut List   *; RUN;

*	Using the array name within a function will pass the variables contained
		in the array to the function (as with a variable shortcut)
	Recall:  The keyword "OF" is required when referring to a shortcut list within a function

	Below is a data set containing data of annual snowfalls
	Each value contains snowfall from July of previous year through June of year listed
		(e.g. 2008 contains snowfall from July 2007 - June 2008)		*; 
DATA	WORK.SnowfallIn;
	INFILE	DATALINES;
	INPUT	City	$
			Yr2000 - Yr2019;
	DATALINES;
Denver  45.6 58.3 30.2 61.8 38.0 39.3 30.4 72.6 46.3 38.1
        60.6 22.8 55.6 78.4 38.4 57.8 72.8 21.8 25.7 48.1
;

*	Goal:  Calculate the average snowfall over the past 20 years   *;
DATA	WORK.SnowfallMean;
	SET	WORK.SnowfallIn;
 
	* Method 1 - Manual *;
	MeanSnowfallIn_Long = (	Yr2000 + Yr2001 + Yr2002 + Yr2003 + Yr2004 +
							Yr2005 + Yr2006 + Yr2007 + Yr2008 + Yr2009 +
							Yr2010 + Yr2011 + Yr2012 + Yr2013 + Yr2014 +
							Yr2015 + Yr2016 + Yr2017 + Yr2018 + Yr2019	) / 20;

	* Method 2 - Using a function *;
	MeanSnowfallIn_Fcn	= MEAN(	Yr2000, Yr2001, Yr2002, Yr2003, Yr2004,
								Yr2005, Yr2006,	Yr2007, Yr2008, Yr2009,
								Yr2010, Yr2011,	Yr2012, Yr2013, Yr2014,
								Yr2015, Yr2016, Yr2017, Yr2018, Yr2019 );

	* Method 3 - Using a function with a shortcut for the variable list *;
	MeanSnowfallIn_FcnWList	= MEAN(OF Yr2000 - Yr2019);

	* Method 4 - Using an array *;
	ARRAY	Year {2000:2019} Yr2000 - Yr2019;
	MeanSnowfallIn_Array = MEAN(OF Year{*});

	RUN;

PROC PRINT DATA = WORK.SnowfallMean;
	VAR MeanSnowfallIn_Long MeanSnowfallIn_Fcn MeanSnowfallIn_FcnWList MeanSnowfallIn_Array;
	RUN;


*	Illustration 4 - Using an Array Name as a Variable Shortcut List   *; RUN;

*	An array may be used as a variable list within an expression

	Goal:  Calculate the difference between each year's snowfall and the average snowfall   *;
DATA	WORK.SnowfallDiffs;
	SET	WORK.SnowfallIn;
 
	ARRAY	Year  {2000:2019} Yr2000 - Yr2019;
	ARRAY	Delta {2000:2019} Diff2000 - Diff2019; * This creates new variables for the differences *;

	DO	i = 2000 TO 2019;
		Delta{i} = Year{i} - MEAN(OF Year{*});
	END;

	FORMAT	Diff2000 - Diff2019	5.1;
	DROP	i;

	RUN;

PROC PRINT DATA = WORK.SnowfallDiffs;
	VAR Yr:;
	RUN;

PROC PRINT DATA = WORK.SnowfallDiffs;
	VAR Diff:;
	RUN;


*	Illustration 5 - Referring to Different Array Elements   *; RUN;

*	Different elements within an array may be referenced in the same calculation
	Think carefully about the relationship between each element and the index variable

	Goal:  Calculate the change in snowfall for each year   *;
DATA	WORK.SnowfallChg;
	SET	WORK.SnowfallIn;

	ARRAY	Year {2000:2019} Yr2000 - Yr2019;
	ARRAY	Change {2001:2019} Chg2001 - Chg2019;

	DO	i = 2001 TO 2019;
		Change{i} = Year{i} - Year{i-1};
	END;

	FORMAT	Chg2001 - Chg2019	5.1;
	DROP	i;

	RUN;

PROC PRINT DATA = WORK.SnowfallChg;
	VAR Yr:;
	RUN;

PROC PRINT DATA = WORK.SnowfallChg;
	VAR Chg:;
	RUN;


* ----------------------------- *
|   Comprehension Check 3.6.2   |
* ----------------------------- *
	The in-stream data below is the number of kilometers (km) each person ran for 5 weeks

	Task:  Use an ARRAY statement to create 5 new variables named 'MilesWk1' to 'MilesWk5'   *;
DATA WORK.RunningLog;
	INFILE	DATALINES;
	INPUT	Name $
			KmWk1 KmWk2 KmWk3 KmWk4 KmWk5;
	DATALINES;
Anderson 10 16 16 26 36
Benson   20 30 37 43 48
Carlson  30 35 37 44 44
;

DATA WORK.RunningLog;
	SET WORK.RunningLog;
	ARRAY Km {*} KmWk1 - KmWk5;
	ARRAY Mi {*} MilesWk1 - MilesWk5;
	RUN;

PROC PRINT DATA = WORK.RunningLog;
	RUN;




*	SECTION 3.6.3 - COMBINING ARRAYS WITH DO LOOPS   *; RUN;

*	1.	Creating an array allows for variables to be referenced using the array name and a subscript
		The subscripts are a sequence of numbers (e.g. 1, 2, ... , 12 or 2000 - 2019, etc)
		Therefore, instead of referring to a set of variables as "January", "February", ... , "December",
			they can be referenced as Month{1}, Month{2}, ... , Month{12}

	2.	DO loops can be used to create an index variable
		The index variable is often a sequence of numbers (e.g. 1, 2, ... , 12 or 2000 - 2019, etc.)

	3.	Therefore, it can be extremely powerful (i.e. efficient) to do the following:
		Step 1.	Create an array containing a group of N variables you want to process in the same way
		Step 2.	Create a DO loop using an index variable from Start-Num TO End-Num (e.g. 1 TO 12 or 2000 TO 2019 etc)
				This index variable will be used as the subscript for the array to refer to each element!
		Step 3.	Use the SAS statement desired, but reference the variables using the array-name & index variable		*;


*	Illustration 1 - Performing the Same Process on Different Variables   *; RUN;

*	The same process may be performed on different variables in several ways

	The data below represent the average monthly high temperature (F) in different cities   *;
DATA	WORK.HighTempsF;
	INFILE	DATALINES;
	INPUT	City	$
			Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec;
	DATALINES;
Denver  43 47 54 61 71 82 88 86 77 66 52 44
Miami   77 78 81 84 87 90 91 91 89 85 81 78
;

*	Goal:  Convert the average high temperatures for each month from Fahrenheit to Celsius

	Although the same process is desired, the statements are different because the variable
		in each statement is a different variable
	So using a DO loop by itself won't work because the statements are different   *;
DATA	WORK.HighTempsC_Difficult;
	SET	WORK.HighTempsF;

	Jan	= (Jan - 32) * 5/9;
	Feb	= (Feb - 32) * 5/9;
	Mar	= (Mar - 32) * 5/9;
	Apr	= (Apr - 32) * 5/9;
	May	= (May - 32) * 5/9;
	Jun	= (Jun - 32) * 5/9;
	Jul	= (Jul - 32) * 5/9;
	Aug	= (Aug - 32) * 5/9;
	Sep	= (Sep - 32) * 5/9;
	Oct	= (Oct - 32) * 5/9;
	Nov	= (Nov - 32) * 5/9;
	Dec	= (Dec - 32) * 5/9;

	FORMAT	Jan -- Dec	5.1;

	RUN;

PROC PRINT DATA = WORK.HighTempsC_Difficult;
	RUN;


*	Illustration 2 - Performing the Same Process on Different Variables - Using an Array   *; RUN;

*	Note:  By using an array, each variable can be referred to using:
		1)	The array name (e.g. Month), and
		2)	An index value (e.g. 7)
	So Month{7} is used instead of "Jul"

	Note:  Although an array is used below, there is no advantage to using it   *;
DATA	WORK.HighTempsC_StillDifficult;
	SET	WORK.HighTempsF;

	ARRAY	Month {*} Jan -- Dec;

	Month{1}	= (Month{1} - 32) * 5/9;
	Month{2}	= (Month{2} - 32) * 5/9;
	Month{3}	= (Month{3} - 32) * 5/9;
	Month{4}	= (Month{4} - 32) * 5/9;
	Month{5}	= (Month{5} - 32) * 5/9;
	Month{6}	= (Month{6} - 32) * 5/9;
	Month{7}	= (Month{7} - 32) * 5/9;
	Month{8}	= (Month{8} - 32) * 5/9;
	Month{9}	= (Month{9} - 32) * 5/9;
	Month{10}	= (Month{10} - 32) * 5/9;
	Month{11}	= (Month{11} - 32) * 5/9;
	Month{12}	= (Month{12} - 32) * 5/9;

	FORMAT	Jan -- Dec	5.1;

	RUN;

PROC PRINT DATA = WORK.HighTempsC_StillDifficult;
	RUN;


*	Illustration 3 - Performing the Same Process on Different Variables - Using an Array & DO Loop   *; RUN;

*	Combining arrays with a DO loop is very efficient!
	The task will be accomplished using the 3 steps outlined above
	Notice that I'm using both:
		1)	The * symbol for the dimension of the array
		2)	The DIM function to calculate the end of the DO loop
	These allow the DATA step to be more easily maintained
		(i.e. if the months desired change)   *;
DATA	WORK.HighTempsC_Easy;
	SET	WORK.HighTempsF;

	* Step 1:  Create an array containing the variables to process in the same manner *;
	ARRAY	Month {*} Jan -- Dec;

	* Step 2:  Create a DO loop using an index variable from Start-Num TO End-Num *;
	DO	i = 1 TO DIM(Month);
		* Step 3:  Use the SAS statement desired, referencing the variables using the array-name & index variable *;
		Month{i} = (Month{i} - 32) * 5/9;
	END;

	FORMAT	Jan -- Dec	5.1;
	DROP	i;

	RUN;

PROC PRINT DATA = WORK.HighTempsC_Easy;
	RUN;


*	Illustration 4 - Using an Index Variable Which Does Not Start at 1   *; RUN;

*	Goal:  Convert the snowfall data from inches to feet   *;
	
DATA	WORK.SnowfallFt;
	SET	WORK.SnowfallIn;

	* Step 1:  Create an array containing the variables to process in the same manner *;
	ARRAY	Year {2000:2019} Yr2000 - Yr2019;

	* Step 2:  Create a DO loop using an index variable from START to END *;
	DO	i = 2000 TO 2019;
		* Step 3:  Use the SAS statement desired, referencing the variables using the array-name & index variable *;
		Year{i} = (Year{i} / 12);
	END;

	FORMAT	Yr2000 - Yr2019	4.1;
	DROP	i;

	RUN;

PROC PRINT DATA = WORK.SnowfallFt;
	RUN;


* ----------------------------- *
|   Comprehension Check 3.6.3   |
* ----------------------------- *
	The in-stream data below is the number of kilometers (km) each person ran for 5 weeks

	Task:  Finish the DO loop which is used to convert each distance in Km to a distance
			in miles (using the equation that Miles=0.621*Kilometers)   *;
DATA WORK.RunningLog;
	INFILE	DATALINES;
	INPUT	Name $
			KmWk1 KmWk2 KmWk3 KmWk4 KmWk5;
	DATALINES;
Anderson 10 16 16 26 36
Benson   20 30 37 43 48
Carlson  30 35 37 44 44
;

DATA WORK.RunningLog;
	SET WORK.RunningLog;
	ARRAY Km {*} KmWk1 - KmWk5;
	ARRAY Miles {*} MilesWk1 - MilesWk5;
	DO i = 1 [finish-statement];
		Miles{i} = [finish-statement];
	END;
	FORMAT	Km: Miles: 5.1;
	DROP i;
	RUN;

PROC PRINT DATA = WORK.RunningLog;
	ID Name;
	RUN;




*	SECTION 3.6.4 - ASSIGNING INITIAL VALUES TO AN ARRAY   *; RUN;


*	Illustration 1 - Assigning Initial Values   *; RUN;

*	This creates in-stream data of 3 test scores from each of 5 students   *;
DATA	WORK.RawScores;
	INFILE	DATALINES;
	INPUT	StudentID
			Test1 - Test3;
	DATALINES;
101 57 65 88
102 74 76 76
103 56 70 75
104 90 80 71
105 82 61 57
;

*	Initial values may be assigned by placing them in a list.  The conventions followed are:
		1.	1 value for is specified for each array element
		2.	Elements and values are matched by position
		3.	Values must be separated by spaces or commas
		4.	The value list must be enclosed in parentheses
		5.	The elements behave as if they were in a RETAIN statement

	Goal:  I would like to replace any score on Test1 that is below 60 with a score of 60, and
			similarly make the minimum scores for Test2 and Test3 to be scores of 65 and 70.	*;
DATA	WORK.AdjustedScores;
	SET	WORK.RawScores;

	ARRAY	Raw			{*} Test1 - Test3;
	ARRAY	Minimum		{*} Minimum1 - Minimum3 (60 65 70); * Creates 3 new variables with values *;
	ARRAY	Adjusted	{3}; * Creates 3 new variables with missing values *;

	DO	i = 1 TO DIM(Raw);
		IF	Raw{i} < Minimum{i}	THEN	Adjusted{i} = Minimum{i};
			ELSE						Adjusted{i} = Raw{i};
	END;

	DROP	i;

	RUN;

PROC PRINT DATA = WORK.AdjustedScores;
	ID StudentID;
	RUN;


*	Illustration 2 - Using a Temporary Array   *; RUN;

*	If variables are only needed for processing (i.e. not for output), temporary variables
		may be created (this increases efficiency)

	The conventions followed are:
		1.	The dimension of the array must be specified (i.e. "*" is not allowed)
		2.	The keyword "_TEMPORARY_" must be specified after the dimension
		3.	No names for elements are allowed
		4.	Elements must be referred to by an array reference (e.g. Minimum{2}) since names aren't in the PDV

	Goal:  Same as above, but without creating variables for the minimum score values   *;
DATA	WORK.AdjustedScores;
	SET	WORK.RawScores;

	ARRAY	Raw			{*} Test1 - Test3;
	ARRAY	Minimum		{3} _TEMPORARY_ (60 65 70);
	ARRAY	Adjusted	{*} Adjusted1 - Adjusted3;

	DO	i = 1 TO DIM(Raw);
		IF	Raw{i} < Minimum{i}	THEN	Adjusted{i} = Minimum{i};
			ELSE						Adjusted{i} = Raw{i};
	END;

	DROP	i;

	RUN;

PROC PRINT DATA = WORK.AdjustedScores;
	ID StudentID;
	RUN;

*	Extension:  Suppose the goal is to see the test scores that are changed
		The following code could accomplish this:		*;
DATA	WORK.ChangedScores	(	DROP	=	Test1 - Test3	);
	SET	WORK.RawScores;

	ARRAY	Raw			{*} Test1 - Test3;
	ARRAY	Minimum		{3} _TEMPORARY_ (60 65 70);

	DO	i = 1 TO DIM(Raw);
		IF	Raw{i} < Minimum{i}	THEN DO;
			TestNum			= i;
			RawScore		= Raw{i};
			AdjustedScore	= Minimum{i};
			Increase		= Minimum{i} - Raw{i};
			OUTPUT	WORK.ChangedScores;
		END;
	END;

	DROP	i;

	RUN;

PROC PRINT DATA = WORK.ChangedScores;
	ID StudentID;
	RUN;




*	SECTION 3.6.5 - ADDITIONAL MATERIAL   *; RUN;

*	Illustration 1 - Re-visiting Using CALL SORTN (from Section 3.4.4)   *; RUN;

*	Creating an example data set   *;
DATA	WORK.Scores;
	INFILE	DATALINES;
	INPUT	Name	$
			Quiz1 - Quiz10;
	DATALINES;
Amy 19 9 8 9 15 6 5 14 8 11
Bob 8 12 20 12 5 15 16 7 6 9
Cal 15 17 5 9 17 15 20 16 16 19
;

*	Previously, we used the SORTN routine to sort the quiz scores   *;
DATA WORK.Scores_Sorted;
	SET WORK.Scores;
	CALL SORTN(OF Quiz:);
	RUN;

PROC PRINT DATA = WORK.Scores_Sorted;
	RUN;

*	If we don't want to over-write the original scores, we could simply use an array to create
		new variables to hold the sorted values
	Let's calculate the quiz average if the teacher drops the lowest 3 quizzes   *;
DATA WORK.Scores_Sorted;
	SET WORK.Scores;
	ARRAY	Existing {*} Quiz1 - Quiz10;
	ARRAY	Ordered {10};

	DO i = 1 TO DIM(Existing);
		Ordered{i} = Existing{i};
	END;

	CALL SORTN(OF O:);

	QuizAvg = MEAN(OF Ordered4-Ordered10);
	FORMAT	QuizAvg 4.1;
	DROP i;
	RUN;

PROC PRINT DATA = WORK.Scores_Sorted;
	RUN;




*	SECTION 3.6.6 - SOLUTIONS   *; RUN;


* ----------------------------- *
|   Comprehension Check 3.6.1   |
* ----------------------------- *
	The in-stream data below is the number of kilometers (km) each person ran for 5 weeks

	Task:  Create an array named 'Km' which contains the 5 variables containing the
				running distances   *;
DATA WORK.RunningLog;
	INFILE	DATALINES;
	INPUT	Name $
			KmWk1 KmWk2 KmWk3 KmWk4 KmWk5;
	DATALINES;
Anderson 10 16 16 26 36
Benson   20 30 37 43 48
Carlson  30 35 37 44 44
;

DATA WORK.RunningLog;
	SET WORK.RunningLog;
	ARRAY Km {*} KmWk1 - KmWk5;
	RUN;


* ----------------------------- *
|   Comprehension Check 3.6.2   |
* ----------------------------- *
	The in-stream data below is the number of kilometers (km) each person ran for 5 weeks

	Task:  Use an ARRAY statement to create 5 new variables named 'MilesWk1' to 'MilesWk5'   *;
DATA WORK.RunningLog;
	INFILE	DATALINES;
	INPUT	Name $
			KmWk1 KmWk2 KmWk3 KmWk4 KmWk5;
	DATALINES;
Anderson 10 16 16 26 36
Benson   20 30 37 43 48
Carlson  30 35 37 44 44
;

DATA WORK.RunningLog;
	SET WORK.RunningLog;
	ARRAY Km {*} KmWk1 - KmWk5;
	ARRAY Miles {*} MilesWk1 - MilesWk5;
	RUN;

PROC PRINT DATA = WORK.RunningLog;
	RUN;


* ----------------------------- *
|   Comprehension Check 3.6.3   |
* ----------------------------- *
	The in-stream data below is the number of kilometers (km) each person ran for 5 weeks

	Task:  Finish the DO loop which is used to convert each distance in Km to a distance
			in miles   *;
DATA WORK.RunningLog;
	INFILE	DATALINES;
	INPUT	Name $
			KmWk1 KmWk2 KmWk3 KmWk4 KmWk5;
	DATALINES;
Anderson 10 16 16 26 36
Benson   20 30 37 43 48
Carlson  30 35 37 44 44
;

DATA WORK.RunningLog;
	SET WORK.RunningLog;
	ARRAY Km {*} KmWk1 - KmWk5;
	ARRAY Miles {*} MilesWk1 - MilesWk5;
	DO i = 1 TO DIM(Km);
		Miles{i} = 0.621 * Km{i};
	END;
	FORMAT	Km: Miles: 5.1;
	DROP i;
	RUN;

PROC PRINT DATA = WORK.RunningLog;
	ID Name;
	RUN;




;	*';	*";	*/;	QUIT;	RUN;
*	End of Program   *; RUN;

